<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Models\Reservation;
use App\Models\Emprunt;
use App\Models\Ouvrages;
use App\Models\Utilisateurs;
use Carbon\Carbon;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\DB;

class ReservationController extends Controller
{
    public function index()
    {
        $userId = Auth::id();

        $reservationsActives = Reservation::with('ouvrage')
            ->where('utilisateur_id', $userId)
            ->whereIn('statut', ['en_attente', 'validee'])
            ->get();

        $reservationsHistorique = Reservation::with('ouvrage')
            ->where('utilisateur_id', $userId)
            ->whereIn('statut', ['refusee', 'annulee']) // adapte selon tes valeurs possibles
            ->paginate(10);

        return view('frontOffice.reservations', compact('reservationsActives', 'reservationsHistorique'));
    }

    // ‚úÖ Client cr√©e une r√©servation
    public function store(Request $request)
    {
        $request->validate([
            'ouvrage_id' => 'required|exists:ouvrages,id',
        ]);

        $userId = Auth::id();
        $ouvrageId = $request->ouvrage_id;

        // üö´ V√©rifie si un emprunt en cours existe (non retourn√©)
        $empruntEnCours = Emprunt::where('ouvrage_id', $ouvrageId)
            ->where('utilisateur_id', $userId)
            ->where(function ($query) {
                $query->where('statut', '!=', 'retourne')
                    ->orWhereNull('date_effective_retour');;
            })
            ->exists();

        if ($empruntEnCours) {
            return back()->with('error', 'Vous ne pouvez pas r√©server ce livre tant que vous ne l‚Äôavez pas retourn√©.');
        }

        // üîÅ V√©rifie s‚Äôil existe une r√©servation active
        $reservationExistante = Reservation::where('ouvrage_id', $ouvrageId)
            ->where('utilisateur_id', $userId)
            ->whereIn('statut', ['en_attente', 'validee'])
            ->exists();

        if ($reservationExistante) {
            return back()->with('error', 'Vous avez d√©j√† une r√©servation active pour ce livre.');
        }

        // üìö Limite de 3 r√©servations en attente
        $nbReservationsEnAttente = Reservation::where('utilisateur_id', $userId)
            ->where('statut', 'en_attente')
            ->count();

        if ($nbReservationsEnAttente >= 3) {
            return back()->with('error', 'Vous avez atteint la limite de 3 r√©servations en attente.');
        }

        // üì¶ V√©rifie le stock
        $ouvrage = Ouvrages::with('stock')->findOrFail($ouvrageId);
        if (!$ouvrage->stock || $ouvrage->stock->quantite <= 0) {
            return back()->with('error', 'Cet ouvrage est actuellement indisponible pour r√©servation.');
        }

        // ‚úÖ Cr√©e la r√©servation
        Reservation::create([
            'ouvrage_id' => $ouvrageId,
            'utilisateur_id' => $userId,
            'date_reservation' => now(),
        ]);

        return back()->with('success', 'R√©servation enregistr√©e. En attente de validation.');
    }

    public function indexAdmin(Request $request)
    {
        // R√©cup√©ration des param√®tres de filtrage
        $status = $request->input('status');
        $dateRange = $request->input('date_range');

        // Requ√™te de base avec les relations n√©cessaires
        $reservationsQuery = Reservation::with([
            'ouvrage',
            'utilisateur' => function ($query) {
                if (method_exists($query->getRelated(), 'trashed')) {
                    $query->withTrashed();
                }
            }
        ])
            ->orderBy('date_reservation', 'desc');

        // Application des filtres
        if ($status && in_array($status, ['confirmee', 'en_attente', 'annulee'])) {
            $reservationsQuery->where('statut', $status);
        }

        if ($dateRange) {
            $dates = explode(' - ', $dateRange);
            if (count($dates) === 2) {
                $startDate = Carbon::createFromFormat('d/m/Y', trim($dates[0]))->startOfDay();
                $endDate = Carbon::createFromFormat('d/m/Y', trim($dates[1]))->endOfDay();
                $reservationsQuery->whereBetween('date_reservation', [$startDate, $endDate]);
            }
        }

        // Pagination
        $reservations = $reservationsQuery->paginate(10);

        // Calcul des statistiques en utilisant les scopes d√©finis dans le mod√®le
        $stats = [
            'total' => Reservation::count(),
            'confirmees' => Reservation::confirmees()->count(),
            'en_attente' => Reservation::enAttente()->count(),
            'annulees' => Reservation::annulees()->count(),
        ];

        // Donn√©es pour les formulaires
        // $ouvrages = Ouvrages::disponibles()->get();
        // $utilisateurs = Utilisateurs::clients()->get();

        return view('admin.reservations', compact(
            'reservations',
            'stats',
            // 'ouvrages',
            // 'utilisateurs'
        ));
    }


    // ‚úÖ Client voit ses r√©servations valid√©es
    public function mesReservations()
    {
        $reservations = Reservation::where('utilisateur_id', Auth::id())
            ->where('statut', 'validee')
            ->get();

        return view('client.reservations.index', compact('reservations'));
    }
    // ‚úÖ Client r√©cup√®re l‚Äôouvrage ‚Üí devient un emprunt
    public function recuperer($id)
    {
        $reservation = Reservation::findOrFail($id);

        if ($reservation->statut === 'validee') {
            Emprunt::create([
                'utilisateur_id' => $reservation->utilisateur_id,
                'ouvrage_id' => $reservation->ouvrage_id,
                'date_emprunt' => now(),
                'date_retour_prevue' => now()->addDays(14),
            ]);

            $reservation->delete();

            return back()->with('success', 'R√©servation r√©cup√©r√©e. Emprunt enregistr√©.');
        }

        return back()->with('error', 'R√©servation non valid√©e.');
    }
    // ‚úÖ Client annule une r√©servation
    public function annuler(Reservation $reservation)
    {
        if ($reservation->utilisateur_id !== Auth::id()) {
            abort(403); // acc√®s interdit
        }
        // V√©rifie si la r√©servation est annulable
        // Seules les r√©servations en attente ou valid√©es peuvent √™tre annul√©es

        if (!in_array($reservation->statut, ['en_attente'])) {
            return back()->with('error', 'Cette r√©servation ne peut pas √™tre annul√©e.');
        }

        $reservation->update(['statut' => 'annulee']);

        return back()->with('success', 'R√©servation annul√©e avec succ√®s.');
    }
    // ‚úÖ Admin annule une r√©servation
    public function annulerAdmin($id)
    {
        $reservation = Reservation::findOrFail($id);

        if ($reservation->statut === 'validee') {
            return back()->with('error', 'Impossible d\'annuler une r√©servation d√©j√† valid√©e.');
        }

        $reservation->update(['statut' => 'annulee']);

        return back()->with('success', 'R√©servation annul√©e avec succ√®s.');
    }
    // ‚úÖ Client annule une r√©servation
    public function annulerClient(Request $request, $id)
    {
        $reservation = Reservation::with('emprunt')->findOrFail($id);
        $userId = Auth::id();

        // V√©rification de l'autorisation
        if ($reservation->utilisateur_id !== $userId) {
            abort(403, 'Acc√®s non autoris√©');
        }

        // V√©rifie si la r√©servation est annulable
        if (!in_array($reservation->statut, ['en_attente', 'validee'])) {
            return back()->with('error', 'Cette r√©servation ne peut pas √™tre annul√©e.');
        }

        DB::beginTransaction();
        try {
            // Si la r√©servation est valid√©e et a un emprunt associ√©
            if ($reservation->statut === 'validee' && $reservation->emprunt) {
                // Supprime l'emprunt associ√©
                $reservation->emprunt->delete();

                // Incr√©mente le stock
                $ouvrage = $reservation->ouvrage;
                if ($ouvrage->stock) {
                    $ouvrage->stock->increment('quantite');
                }
            }

            // Met √† jour le statut de la r√©servation
            $reservation->update(['statut' => 'annulee']);

            DB::commit();
            return redirect()->route('frontOffice.reservations')
                ->with('success', 'R√©servation annul√©e avec succ√®s.');
        } catch (\Exception $e) {
            DB::rollBack();
            return back()->with('error', 'Une erreur est survenue lors de l\'annulation: ' . $e->getMessage());
        }
    }
    // Valider une r√©servation => cr√©e un emprunt
    public function validerAdmin($id)
    {
        $reservation = Reservation::with('ouvrage.stock')->findOrFail($id);

        if ($reservation->statut !== 'en_attente') {
            return back()->with('error', 'Cette r√©servation a d√©j√† √©t√© trait√©e.');
        }

        $stock = $reservation->ouvrage->stock;
        if (!$stock || $stock->quantite < 1) {
            return back()->with('error', 'Stock insuffisant pour valider cette r√©servation.');
        }

        DB::beginTransaction();

        try {
            // Mettre √† jour la r√©servation
            $reservation->update(['statut' => 'validee']);

            // Cr√©er l'emprunt
            Emprunt::create([
                'utilisateur_id' => $reservation->utilisateur_id,
                'ouvrage_id' => $reservation->ouvrage_id,
                'date_emprunt' => now(),
                'date_retour' => now()->addDays(14),
                'statut' => 'en_cours'
            ]);

            // D√©cr√©menter le stock
            $stock->decrement('quantite');

            DB::commit();
            return back()->with('success', 'R√©servation valid√©e et emprunt cr√©√© avec succ√®s.');
        } catch (\Exception $e) {
            DB::rollBack();
            return back()->with('error', 'Une erreur est survenue lors de la validation: ' . $e->getMessage());
        }
    }
}
